---
title: 'Concurrent Mode and Lane Prioritization in React 18'
date: '2024-08-11'
lastmod: '2024-08-11'
tags: ['react-js', 'in-depth']
draft: false
summary: 'When an event triggers an update, React determines the update lane based on the event''s priority. If a new update with a higher priority arrives, React cancels the ongoing task and schedules a new task for this higher-priority update. React then continues by scheduling tasks for the remaining lanes in descending order of priority, effectively creating a cascading sequence of tasks.'
images: []
---

## Introduction
React has evolved over the years, and one of the significant advancements is the introduction of Concurrent Mode. This mode allows React to break free from the constraints of synchronous rendering, enabling more flexible and responsive user interfaces. Concurrent Mode brings along a sophisticated update priority system, which ensures that the most crucial updates are handled promptly while less critical updates can be deferred.\
In this blog, we’ll delve into the technical intricacies of Concurrent Mode in React, particularly focusing on how updates are triggered, scheduled, and prioritized.

- [Key Steps in React Concurrent Mode](#key-steps-in-react-concurrent-mode)
- [Lanes and Priority System in React](#lanes-and-the-priority-system)
- [Real-Life Analogy](#real-life-analogy)


The call graph of prioritized updates illustrates as below:
![handle-update-priority-call-graph](/static/images/posts/concurrent-mode-and-update-priority-in-react18/handle-update-priority-call-graph.png)

![schedule-task-call-graph](/static/images/posts/concurrent-mode-and-update-priority-in-react18/schedule-task-call-graph.png)


## [Key Steps in React Concurrent Mode](#key-steps-in-react-concurrent-mode)

1. **Triggering an Update**: An update can be initiated by various actions, including user interactions, network responses, or timers.

2. **Scheduling the Update**: React determines the priority of each update task and adds an update object to the fiber's update queue.

3. **Rendering**: React calls the component function and creates or updates the fiber tree based on the changes.

4. **Commit**: All changes are committed to the real DOM in a single, synchronous step, followed by the execution of `useLayoutEffect()` and `useEffect()` hooks.



## [React Priority System](#react-priority-system)
There are three priority systems in React:

1. **Event Priority**: marks the priority of user events based on the type of event. Common event priorities include **Discrete**, **Continuous**, and **Default**. For example,\
Discrete events (e.g., click, keydown, focus) have the highest priority because they directly affect user input responsiveness.  \
On the other hand, Continuous events (e.g., mousemove, drag, scroll, mouseover) can be handled more gradually to avoid blocking the browser's main thread.

2. **Scheduler Priority**: used by React's internal scheduler to prioritize tasks. React defines several scheduler priority levels, such as **Immediate**, **UserBlocking**, **Normal**, **Low**, and **Idle**, each indicating how soon a task should be processed.\
The scheduler priority level can be found in the following file:\
https://github.com/facebook/react/blob/v18.3.1/packages/scheduler/src/forks/Scheduler.js#L324


3. **Lane Priority**: categorize the fiber's updates into different buckets (or lanes), where each fiber may have multiple updates with different priorities.

When an event triggers an update, React calculates the update lane based on the event priority.  The Scheduler uses lane priorities to manage and schedule work. This way, high-priority updates (like those affecting user inputs) can jump ahead of less critical updates (like logging or analytics services updates).



## [Update Lanes](#update-lanes)
React defines 31 lanes, represented in binary form, allowing multiple lanes (or priorities) to be represented by a single number. Each bit in a binary number corresponds to a different type of work or priority level, enabling efficient merging or sorting of updates using bitwise operations.

The 31 lanes categorizes into 7 groups, with priority levels arranged from high to low:\
`SyncLanes` > `InputContinuousLanes` > `DefaultLanes` > `TransitionLanes` > `RetryLanes` > `IdleLanes` > `OffScreenLanes`


The lanes definition can be found in the following file: \
https://github.com/facebook/react/blob/v18.3.1/packages/react-reconciler/src/ReactFiberLane.new.js#L34

```
export const TotalLanes = 31;

export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;

export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;

export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;
export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000000100;

export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;
export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000010000;

const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;
const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;

```

React uses bitwise operations to manipulate lanes and determine the priority of updates efficiently. For instance, to find the highest priority lane, we may perform a bitwise AND operation between lanes and (Not lanes).
```
var lanes = 0b01011000;
~lanes; // 0b10101000
lanes & ~lanes ; // 0b00001000
```


To merge lanes, we may perform bitwise OR operation, for example:
```
var pendingLanes = 0b0101;
var updateLane = 0b0011;
pendingLanes |= updateLane; // 0b0111
```


## [Assign Update's Priority](#assign-updates-priority)
When an event triggers an update, React calculates the update lane based on the event priority. The update lane is then passed to `enqueueConcurrentHookUpdate()` to mark the fiber for updating. Finally, `scheduleUpdateOnFiber()` schedules the update based on the lane priority.
The call graph is illustrated as below:
![handle-update-priority-call-graph](/static/images/posts/concurrent-mode-and-update-priority-in-react18/handle-update-priority-call-graph.png)


### [1. Evaluating Current Update Lane](#1-evaluating-current-update-lane)
When `setState()` is invoked, React calls `requestUpdateLane()` to determine the priority lane for the update.
- **Transition Task**: If the update is part of a transition task (like `Suspense`, `useTransition`, or `useDeferredValue`), React searches for an available lane among the 16 transition lanes. These lanes are cycled through, so once lane 16 is reached, the next transition update will loop back to lane 1.

- **Event-Triggered Updates**: If the update is not part of a transition task, React invokes `getCurrentUpdatePriority()` to determine the priority of the current task, which is based on the event that triggered the update. This ensures that event-driven updates are assigned the correct level of urgency.

- **Default Handling for Non-Event Updates**: In cases where the update is triggered by an I/O operation or other non-event-driven source, React assigns the update to the `DefaultLane`. This provides a fallback mechanism for updates that don't have an associated event or transition context, ensuring they are still processed appropriately.

![evaluating-update-lane](/static/images/posts/concurrent-mode-and-update-priority-in-react18/evaluating-update-lane.png)



### [2. Marking Pending Fibers in the Tree](#2-marking-pending-fibers-in-the-tree)
React creates an update object with the determined lane and attaches it to the fiber node using `enqueueConcurrentHookUpdate()`. This function triggers `markUpdateLaneFromFiberToRoot()`, which is responsible for marking all affected fibers from the current fiber up through the parent path to the root. This process serves two primary purposes:

- **Merging Update Lane Priorities**: The function merges the update lane priority into the lanes property of the current fiber node. This merge indicates that the fiber has pending work that needs to be processed during the next render.

- **Propagating Child Fiber Lanes**: It also merges the lanes of all child fibers into the childLanes property of the parent fiber. This merge signals that there is pending work within the child fibers that the parent needs to account for.

For example, consider the Counter component described above. When a button in the Counter component is clicked, triggering the setCount() method that invokes `setState()` three times directly and one within a startTransition() method. As a result, the update lane of the Counter fiber becomes `0b10000001` (or decimal `129`), which is a combination of a TransitionLane1 (`0b1000000`) and a sysLane (`0b1`). This combination ensures that both high-priority and transitional updates are correctly prioritized and handled by React.

Then React sets the lanes property of the Counter fiber to `0b10000001` and the childLanes property to `0`. The fibers along the path from the Counter to the root are updated accordingly, with their lanes reflecting the combined priorities of the updates.

![marking-pending-fibers-in-the-tree](/static/images/posts/concurrent-mode-and-update-priority-in-react18/marking-pending-fibers-in-the-tree.png)
![marking-pending-fibers-in-the-tree-screenshot](/static/images/posts/concurrent-mode-and-update-priority-in-react18/marking-pending-fibers-in-the-tree-screenshot.png)


### [3. Prioritizing Update](#3-prioritizing-update)
React invokes the scheduleUpdateOnFiber() function to schedule a re-render. Here’s how React manages this process:

a) **Updating Root Pending Lane**: React invokes `markRootUpdated()` to combine all fibers' update lanes into the root's `pendingLanes`, and set the `eventTime` for the root, marking the time when the current event occurred. After updating the root, React calls 1ensureRootIsScheduled()1, which orchestrates several key actions below.

b) **Preventing Lane Starvation**: React invokes `markStarvedLanesAsExpired()` to handle lanes that have exceeded their expiration time. Lanes marked as expired are prioritized for synchronous execution in the next task cycle, bypassing time slicing. This function calculates the expiration time for the current update lane, stores it in the root's expirationTimes array, and combines the expired lanes into `root.expiredLanes`, ensuring they are processed without delay.


c) **Batching Updates**: React uses `getHighestPriorityLane()` to determine the most urgent update lane from the root fiber. If the new highest priority update matches the current pending task priority (`root.callbackPriority`), React skips scheduling a new task and returns immediately. Otherwise, it updates `root.callbackPriority` with the new highest priority lane.\
This mechanism prevents redundant task scheduling and ensures that updates within the same event cycle are batched together, optimizing performance. For instance, in the above Counter component example, three `setState()` calls within the click handler are batched, resulting in only one task being scheduled. A fourth `setState()` call within a `startTransition` is assigned a different lane, thus another scheduled task will process it.

![batching-update](/static/images/posts/concurrent-mode-and-update-priority-in-react18/batching-update.png)


d) **Interrupting and Rescheduling Tasks**: When a new update with a higher priority lane than the current `root.callbackPriority` arrives, React cancels the ongoing task to prevent lower-priority work from blocking more critical updates. Then React schedules a new task with this higher priority lane. This newly scheduled task processes this urgent update first, ensuring that React prioritizes the most important work. Once this higher priority update is completed, React continues by scheduling another task for the next highest priority lane, effectively creating a cascading sequence of tasks based on priority.\
This cascading approach ensures that React processes updates in order of urgency, dynamically adjusting to new, higher-priority tasks as they emerge.


e) **Scheduling New Tasks**: If the highest priority update lane is `SyncLane`, React recognizes the need for immediate execution. In this case, it invokes `scheduleSyncCallback()` to maintain a queue of synchronous tasks. Following this, `flushSyncCallbacks()` is called to execute all pending updates in the highest priority lane without delay. \
For other lanes, React uses `scheduleCallback()`, allowing the task to be processed concurrently. During the rendering commit phase, React once again calls `ensureRootIsScheduled()` to continue processing updates, starting with the next highest priority lane. This priority-based scheduling system ensures that React efficiently manages updates, processing them lane by lane, and dynamically responding to new, higher-priority updates as they come in.

![handle-update-priority-call-graph](/static/images/posts/concurrent-mode-and-update-priority-in-react18/handle-update-priority-call-graph.png)



## [Real-Life Analogy](#real-life-analogy)

Imagine a programmer busy with a task while a large group of people constantly ask questions. Some questions are urgent, some are repetitive, and some are time-consuming. The programmer can't address these issues all at once.

To improve the workflow, a product manager steps in to evaluate the priority of each question, placing them into a demand pool. The programmer sets a timer, and at each interval, checks if more urgent tasks have arisen. If they have, he pauses his current task to address the more urgent ones.

In this analogy, the product manager acts as the React scheduler, while the programmer represents the rendering mechanism. React, however, operates with a much shorter timer, often just 5 milliseconds, ensuring that even during intensive rendering, the user experience remains smooth.
